import streamlit as st
import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.multioutput import MultiOutputRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score

st.set_page_config(page_title="Smart Layout AI", page_icon="üèóÔ∏è", layout="centered")

st.markdown("""
    <style>
    html, body, [class*="css"]  {
        font-family: 'Segoe UI', sans-serif;
        background-color: #f0f4f8;
    }
    .stButton>button {
        background: linear-gradient(to right, #0f4c75, #3282b8);
        color: white;
        font-size: 18px;
        border-radius: 10px;
        padding: 0.6em 2em;
    }
    div[data-testid="metric-container"] {
        background-color: white;
        border-radius: 12px;
        padding: 1em;
        margin: 10px 0;
        box-shadow: 0px 4px 12px rgba(0,0,0,0.08);
    }
    div[data-testid="metric-container"] > label, div[data-testid="metric-container"] > div {
        color: #1f2937 !important;
        font-weight: 600;
        font-size: 18px;
    }
    </style>
""", unsafe_allow_html=True)

df = pd.read_excel("layoutdata.xlsx")
df.columns = df.columns.str.strip()
df['‡∏´‡∏•‡∏±‡∏á‡∏ï‡πà‡∏≠‡∏ã‡∏≠‡∏¢'] = df['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á'] / df['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ã‡∏≠‡∏¢'].replace(0, 1)
df['%‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß'] = df['‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß'] / df['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á'].replace(0, 1)
df['%‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î'] = df['‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î'] / df['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á'].replace(0, 1)
df['%‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°'] = df['‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°'] / df['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á'].replace(0, 1)
df['%‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢'] = df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢(‡∏ï‡∏£‡∏°)'] / df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)']
df['%‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏ò‡∏≤'] = df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏ò‡∏≤(‡∏ï‡∏£‡∏°)'] / df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)']
# ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏ñ‡∏ô‡∏ô‡πÉ‡∏ô‡∏≠‡∏î‡∏µ‡∏ï‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á
df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏ô‡∏ô(‡∏ï‡∏£‡∏°)'] = df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏ò‡∏≤(‡∏ï‡∏£‡∏°)'] - df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏ß‡∏ô(5%‡∏Ç‡∏≠‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢)']
df['%‡∏ñ‡∏ô‡∏ô‡πÉ‡∏ô‡∏™‡∏≤‡∏ò‡∏≤‡∏£‡∏ì‡∏∞'] = df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏ô‡∏ô(‡∏ï‡∏£‡∏°)'] / df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏ò‡∏≤(‡∏ï‡∏£‡∏°)']
‡∏ñ‡∏ô‡∏ô_‡∏ï‡πà‡∏≠_‡∏™‡∏≤‡∏ò‡∏≤‡∏£‡∏ì‡∏∞_‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ = df['%‡∏ñ‡∏ô‡∏ô‡πÉ‡∏ô‡∏™‡∏≤‡∏ò‡∏≤‡∏£‡∏ì‡∏∞'].mean()


X_raw = df[['‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î', '‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£', '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)', '‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô']]
y_ratio = pd.DataFrame({
    '‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏ò‡∏≤': df['%‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏ò‡∏≤'],
    '‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢': df['%‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢'],
    '‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏ß‡∏ô': df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏ß‡∏ô(5%‡∏Ç‡∏≠‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢)'] / df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)'],
    '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ï‡πà‡∏≠‡πÑ‡∏£‡πà': df['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á'] / (df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)'] / 1600),
    '‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°': df['%‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°'],
    '‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î': df['%‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î'],
    '‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß': df['%‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß'],
    '‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå': df['‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå'] / df['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á'].replace(0, 1)
})

X = pd.get_dummies(X_raw, columns=['‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î', '‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£', '‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô'])
X_train, X_test, y_train, y_test = train_test_split(X, y_ratio, test_size=0.2, random_state=42)
model = MultiOutputRegressor(RandomForestRegressor(n_estimators=100, random_state=42)).fit(X_train, y_train)
avg_‡∏ã‡∏≠‡∏¢‡∏ï‡πà‡∏≠‡∏´‡∏•‡∏±‡∏á = df.groupby('‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£')['‡∏´‡∏•‡∏±‡∏á‡∏ï‡πà‡∏≠‡∏ã‡∏≠‡∏¢'].mean().to_dict()

# ‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà
df_group = df[['‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£', '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)', '‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°', '‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î', '‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß', '‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå', '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á']].copy()
df_group['%‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°'] = df_group['‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°'] / df_group['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á'].replace(0, 1)
df_group['%‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î'] = df_group['‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î'] / df_group['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á'].replace(0, 1)
df_group['%‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß'] = df_group['‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß'] / df_group['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á'].replace(0, 1)
df_group['%‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå'] = df_group['‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå'] / df_group['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á'].replace(0, 1)
bins = [0, 20000, 40000, 60000, 80000, 100000, float("inf")]
labels = ["‚â§20k", "20k-40k", "40k-60k", "60k-80k", "80k-100k", "100k+"]
df_group['‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà'] = pd.cut(df_group['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)'], bins=bins, labels=labels)
grouped_ratio = df_group.groupby(['‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£', '‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà'], observed=True)[["%‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°", "%‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î", "%‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß", "%‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå"]].mean().round(3)
grouped_ratio_dict = grouped_ratio.to_dict(orient="index")

def adjust_by_grade_policy(grade, ratios):
    # Existing policy for PRIMO, BELLA, WATTANALAI
    if grade in ['PRIMO', 'BELLA', 'WATTANALAI']:
        ratios[2] = min(ratios[2], 0.2) # Max 20% detached (‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß)
        remain = 1 - ratios[2] - ratios[3] # Recalculate remaining for townhome/semi-detached
        ratios[0] = remain * 0.65 # ‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏° (Index 0)
        ratios[1] = remain * 0.35 # ‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î (Index 1)

    # NEW POLICY: For grades that should only have detached houses (townhome, semi-detached, commercial are 0)
    # Based on data analysis, grades like MONTARA, PRIMAVILLA, and some PARKVILLE instances
    # tend to be exclusively detached. This enforces that policy.
    # 'PARKVILLE' and 'PARK VILLE' are treated as the same grade for this policy.
    if grade in ['MONTARA', 'PRIMAVILLA', 'PARKVILLE', 'PARK VILLE']:
        ratios[0] = 0.0  # Townhome
        ratios[1] = 0.0  # Semi-detached
        ratios[3] = 0.0  # Commercial
        ratios[2] = 1.0  # Detached - set to 100% of remaining plots if other types are 0

    return ratios

# ====== FORM ======
st.markdown("## üìã ‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£")
with st.form("input_form"):
    col1, col2 = st.columns(2)
    with col1:
        ‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î = st.selectbox("üìç ‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î", sorted(df['‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î'].dropna().unique()))
        ‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á = st.selectbox("üß±Ô∏è ‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô", sorted(df['‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô'].dropna().unique()))
    with col2:
        ‡πÄ‡∏Å‡∏£‡∏î = st.selectbox("üèß ‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£", sorted(df['‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£'].dropna().unique()))
        ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà_‡∏ß‡∏≤ = st.number_input("üìÄ ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£ (‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ß‡∏≤)", min_value=250, value=7500, step=100)
    submitted = st.form_submit_button("üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå")

# ====== PREDICT ======
if submitted:
    area = ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà_‡∏ß‡∏≤ * 4
    rai = area / 1600
    input_df = pd.DataFrame([{ '‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î': ‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î, '‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£': ‡πÄ‡∏Å‡∏£‡∏î, '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)': area, '‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô': ‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á }])
    encoded = pd.get_dummies(input_df)
    for col in X.columns:
        if col not in encoded.columns:
            encoded[col] = 0
    encoded = encoded[X.columns]
    pred = model.predict(encoded)[0]

    ‡∏û‡∏ó_‡∏™‡∏≤‡∏ò‡∏≤ = pred[0] * area
    ‡∏û‡∏ó_‡∏Ç‡∏≤‡∏¢ = pred[1] * area
    ‡∏û‡∏ó_‡∏™‡∏ß‡∏ô = pred[2] * area
    ‡∏û‡∏ó_‡∏ñ‡∏ô‡∏ô = ‡∏û‡∏ó_‡∏™‡∏≤‡∏ò‡∏≤ * ‡∏ñ‡∏ô‡∏ô_‡∏ï‡πà‡∏≠_‡∏™‡∏≤‡∏ò‡∏≤‡∏£‡∏ì‡∏∞_‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢
    ‡∏´‡∏•‡∏±‡∏á‡∏£‡∏ß‡∏° = pred[3] * rai

    ratio_hist = get_ratio_from_lookup(‡πÄ‡∏Å‡∏£‡∏î, area)
    # ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏ß‡πà‡∏≤ ratio_hist ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà None ‡∏Å‡πà‡∏≠‡∏ô‡∏ô‡∏≥‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
    if ratio_hist is not None:
        ‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°, ‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î, ‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß, ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå = [‡∏´‡∏•‡∏±‡∏á‡∏£‡∏ß‡∏° * r for r in ratio_hist]
    else:
        # ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô lookup table ‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
        # ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° policy ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ
        total = sum(pred[4:8]) or 1
        raw_ratios = [r / total for r in pred[4:8]]
        raw_ratios = adjust_by_grade_policy(‡πÄ‡∏Å‡∏£‡∏î, raw_ratios)
        ‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°, ‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î, ‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß, ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå = [‡∏´‡∏•‡∏±‡∏á‡∏£‡∏ß‡∏° * r for r in raw_ratios]

    ‡∏ã‡∏≠‡∏¢ = ‡∏´‡∏•‡∏±‡∏á‡∏£‡∏ß‡∏° / avg_‡∏ã‡∏≠‡∏¢‡∏ï‡πà‡∏≠‡∏´‡∏•‡∏±‡∏á.get(‡πÄ‡∏Å‡∏£‡∏î, 12)

    st.markdown("---")
    st.markdown("## üåü ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå")
    col1, col2 = st.columns(2)
    with col1:
        st.metric("‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏ò‡∏≤‡∏£‡∏ì‡∏∞", f"{‡∏û‡∏ó_‡∏™‡∏≤‡∏ò‡∏≤ / 4:,.0f} ‡∏ï‡∏£.‡∏ß‡∏≤")
        st.metric("‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢", f"{‡∏û‡∏ó_‡∏Ç‡∏≤‡∏¢ / 4:,.0f} ‡∏ï‡∏£.‡∏ß‡∏≤")
        st.metric("‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏ß‡∏ô", f"{‡∏û‡∏ó_‡∏™‡∏ß‡∏ô / 4:,.0f} ‡∏ï‡∏£.‡∏ß‡∏≤")
        st.metric("‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏ô‡∏ô", f"{‡∏û‡∏ó_‡∏ñ‡∏ô‡∏ô / 4:,.0f} ‡∏ï‡∏£.‡∏ß‡∏≤")
    with col2:
        st.metric("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏£‡∏ß‡∏°", f"{‡∏´‡∏•‡∏±‡∏á‡∏£‡∏ß‡∏°:,.0f} ‡∏´‡∏•‡∏±‡∏á")
        st.metric("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ã‡∏≠‡∏¢", f"{‡∏ã‡∏≠‡∏¢:,.0f} ‡∏ã‡∏≠‡∏¢")

    st.markdown("### üè° ‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ö‡πâ‡∏≤‡∏ô")
    st.markdown(f"""
        - ‡∏ó‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏Æ‡∏°: **{‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°:,.0f}** ‡∏´‡∏•‡∏±‡∏á  
        - ‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î: **{‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î:,.0f}** ‡∏´‡∏•‡∏±‡∏á  
        - ‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß: **{‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß:,.0f}** ‡∏´‡∏•‡∏±‡∏á  
        - ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå: **{‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå:,.0f}** ‡∏´‡∏•‡∏±‡∏á  
    """)

    y_pred_test = model.predict(X_test)
    mae_test = mean_absolute_error(y_test, y_pred_test)
    r2_test = r2_score(y_test, y_pred_test)

    st.markdown("### üìà ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏≠‡∏á‡πÇ‡∏°‡πÄ‡∏î‡∏• (Test Set)")
    st.write(f"**MAE (Mean Absolute Error):** {mae_test:.4f}")
    st.write(f"**R¬≤ Score:** {r2_test:.4f}")

st.markdown("---")
st.caption("Developed by mmethaa | Smart Layout AI üöÄ")
